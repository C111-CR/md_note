## C语言相关

- 共用体 --- 只保留某一个值，其大小为最大的那个数据类型的长度

  ```c++
  union three{
      int intVal;
      long longVal;
      double doubleVal;
  };
  
  three demo;				//demo的长度应该等于一个double的长度
  demo.intVal = 4;
  demo.doubleVal = 17.1;	//此时intVal的值被丢弃
  ```

  ```c++
  // 匿名共用体
  struct node{
      int value;
      union{
          int x;
          double y;
      };
  };
  
  node data;
  data.x = 10;
  data.y = 3.14;		// x和y都作为结构体中的一个元素
  					// 不过他们共用一个数据空间，即同个地址
  ```

  共用体的主要作用是节省内存。



- #### `extern`

  `extern`是C语言中的关键字，它会**声明**一个**全局**变量或者函数，表明变量或者函数是**定义**在其他其他文件中的。

  ​	**定义**：表示创建变量或分配存储单元。

  ​	**声明**：说明变量的性质，但并不分配存储单元。

  ```c
  extern int i;			// 只是声明，但没有分配内存空间给变量i
  int i;					// 是定义，给变量i分配了4个字节
  extern int i = 17;		// 是定义，但使用extern时不应该对变量进行定义
  ```

  `extern`往往用来在头文件中声明变量（对于函数而言，如果没有函数体，即`{}`中的代码，那么就是声明；反之，则为定义。因此，函数的定义与声明很好区分，不需要用到`extern`），以便在多个`.c`/`.cpp`文件中定义和使用该变量。

  例如，在`a.h`文件中声明变量`extern map<int, int> mp;`，之后可以在`a.cpp`中定义**全局**变量`map<int,int> mp;`（只能在函数外定义），然后再在`main.cpp`中使用变量`mp[0] = 1;` 

  需要注意的是，在头文件中使用`extern`会声明一个全局变量，之后需要经过定义才能够使用该变量（在任意`.cpp`文件的全局变量部分定义），而且这个全局变量只能定义一次。

  关于多文件编程：在头文件(`a.h`)中声明 **变量/函数/类**，然后再在对应的cpp文件(`a.cpp`)中进行定义（变量，成员/非成员函数的主体），之后再编写`main`函数以运行代码。

  

- #### `extern "C"`

  `extern "C"`是C++中的一种用法（无法在C语言中使用），其作用是 修饰一段代码，将其用C语言的方式进行编译。

  ###### 那么，使用C语言方式进行编译与使用C++方式进行编译又有什么区别呢？

  在C++中，支持函数重载：

  ```c++
  void func();
  void func(int a, int b);
  void func(double a, float b);
  ```

  但在C语言中如果编译函数`func()`，其在符号库中的名字为`_func`，也就是说与参数无关，只和函数名字相关。因此，C语言中无法实现函数重载，因为他们在符号库中的标识都是一样的。

  而在C++中，一个函数编译后生成的名字是用函数名加上参数类型和数量构成的，比如`void func(int a, int b)`对应的名字是`_func_int_int`，而`void func(double a, float b)`对应的名字是`_func_double_float`，这样实际上就将名字相同的重载函数变成了不同的函数（编译过后）。

  ###### 因此，`extern "C"` 的作用就显示出来了：实现C++与C语言的混合编程

  代码一旦被`extern "C"`修饰之后，它便以C语言的方式工作**（编译阶段：以C的方式编译；链接阶段：寻找C方式编译生成的符号）**。 在C语言中引用 `C++` 库的函数或 C++中引用 `C` 库的函数，都可以通过这个方式实现兼容。

  - 在C++中使用C语言库：

    ```c++
    // C++中的 <stdio.h> 有以下代码
    #ifdef __cplusplus
    extern "C" {
    #endif
     // ...
    #ifdef __cplusplus
    }
    #endif
    ```

    其中，宏定义`__cplusplus`是识别是否使用了C++进行编译的标志，这样一来，就可以在使用C++时直接调用C语言的库而不用担心使用C++的编译器无法编译C语言库的代码。







