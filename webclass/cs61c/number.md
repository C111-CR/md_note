​	

## 二进制数

### 1.无符号数

$0000 0000 0000 0000_2 = 0_{10}$  (16位无符号数最小值)

...

$1111 1111 1111 1111_2 = 4,294,967,295_{10}$  (16位无符号数最大值)



### 2.有符号数

#### a.补码的表示与计算

eg: 一个16位有符号数，其机器码(补码)的10进制值计算方式是：

### $x_{15}*(-2^{15})$  +  $x_{14}*2^{14}$  +  ...  +  $x_1*2^1$  +  $x_0*2^0$ 

最高位(15)为符号位，后面15位为数位

正数为0，故$x_{15}$项值为0；负数为1，故$x_{15}$项值为$-2^{15}$

##### $1000,0000,0000,0000_2 = -2,147,483,648_{10}$ 为负数最大数

##### ...

##### $1111,1111,1111,1111_2 = -1_{10}$

##### $0000,0000,0000,0000_2 = 0_{10}$ 

##### ...

##### $0111,1111,1111,1111_2 = 2,147,483,647_{10}$为正数最大值；



#### b.补码的取反

##### 由 $\bar{x} + x = 1111,..,1111_2 = -1_{10}$ ($\bar{x}$ 表示 x 按位取反) 得

##### $-x = \bar{x} + 1_{10}$

##### 所以对于一个数，求其相反数的补码：只需将其补码按位取反(包括符号位)后，最低位加1(即加$1_{10}$)



#### c.补码的符号扩展

##### 将16位补码数 $1001,0101,0000,0011_2$ 扩展为32位的补码数

##### 首先，将16位数复制到32位数的后16位；

##### 再将符号位复制填满32位数的前16位。

##### 即： $1111,1111,1111,1111, 1001,0101,0000,0011_2$

对于正数也是如此：后16位照抄，前16位用其符号位填满



### 3.加法运算

不管对于无符号数还是补码数，所有位都直接参与运算（即补码的符号位也参与运算）；

当无符号数出现溢出，则真的溢出了。。。

但对于补码数来说：

##### 正数 + 正数 / 负数 + 负数 --- 如果溢出则真的是溢出(overflow)

##### 正数 + 负数 --- 即使符号位溢出，也是正确结果



