## TCP

- TCP首部

  ![img](https://pic3.zhimg.com/80/v2-cbb0a8fa22c68fd974ae3eddd0b3b046_720w.webp)

  - TCP用四个要素确定一个唯一的连接：**(Source主机的IP地址 + 端口号)**和**(目标主机的IP地址 + 端口号)** IP地址由网络层的IP协议首部获得，端口号为16位（0~65535，其中1024以下是系统保留的端口号，1024到65535由用户使用），端口号与应用程序对应，表示这个TCP包由哪个应用程序发出，以及需要发送到哪个应用程序。

  - TCP的序号和确认号：
    **32位序号 seq**（Sequence number ）：TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据**有序**，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
    **32位确认号 ack**（Acknowledge number）：TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。
  - 标志位
    - **SYN** --- 同步标志位，用于建立会话连接，同步序列号；
    - **ACK** --- 确认标志位
    - **FIN** --- 完成标志位，表示我已经没有数据要发送了，即将关闭连接；

  

- 三次握手 --- 建立连接

  <img src="https://pic1.zhimg.com/80/v2-8ce8c897b4d5e7397b25eb4d4b31d7fc_720w.webp" alt="img" style="zoom: 67%;" />

  - 第一次握手（客户端  >>> 服务器端）

    - **SYN **标志位置为1
    - 随机产生一个序号值seq=J，保存在首部的**seq**序列号
    - 客户端进入**SYN_SENT**状态，等待服务器端确认

  - 第二次握手（服务器端  >>> 客户端）

    - 服务器收到请求数据包后，根据**SYN = 1**得知客户端请求建立连接
    - **SYN **和 **ACK** 标志位被置为1
    - 确认号 **ack = J + 1** ，并随机产生一个序号值seq=K，保存在首部中
    - 服务器端进入**SYN_RCVD**状态

  - 第三次握手（客户端 >>> 服务器端）

    - 客户端收到确认数据包后，检查ack是否等于J+1以及ACK标志位是否为1
    - 检查通过则将 **ACK** 置为1，**ack = K + 1**，再将数据包发送给服务器端
    - 服务器端进行检查，若检查通过则成功建立该连接，客户端与服务器端进入 **ESTABLISHED** 状态，可以进行数据传输了

  - 为什么需要三次握手？

    TCP 三次握手跟现实生活中的人与人打电话是很类似的：

    三次握手：
    	“喂，你听得到吗？”
    	“我听得到呀，你听得到我吗？”
    	“我能听到你，今天 balabala……“

    通过三次握手来确保，双方都进入了通信状态。如果只有第一次握手，Client发出通信请求后就进入通信状态，开始发送数据或者等待Server的数据，若从Client到Server的线路上的路由器出现问题，没有建立连接，那么Client会白白等待或者发送的数据都浪费了；因此Client发送请求通信的数据包给Server后，Server返回确认报文的目的是确认从Client到Server的传输路线没有问题。同理，需要第三次握手的原因也是为了确认从Server到Client的传输线路没有问题。

  

- 四次挥手 --- 关闭连接

  - 挥手过程可由客户端发送，也可以由服务器端发送。

    假如由Client发出关闭连接请求：

    <img src="https://img-blog.csdnimg.cn/3ca4f59c07ed4c83b9ca7a16ba8344f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzU2NjQ5NTU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />

  - 第一次挥手

    - 设置终止位**FIN = 1**，表明这是一个TCP连接释放报文段

    - 设置**seq = u**，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1
    - Client进入**FIN-WAIT-1**状态

  - 第二次挥手

    - Server发送确认报文，**ACK = 1**， **ack = u + 1**， **seq = v**
    - Server进入**CLOSE-WAIT**状态

  - 第三次挥手

    - 在Client接收到Server的确认报文后，进入**FIN-WAIT-2**状态
    - 直到Server将剩余的数据发送完毕后，Server向Client发送连接释放报文
    - 同第一次挥手一样，设置**FIN = 1**, **seq = w**
    - 发送完连接释放报文之后，Server进入**LAST-ACK**状态

  - 第四次挥手

    - Client收到连接释放报文后，同第二次挥手一样，需要发送回确认报文
    - 设置 **ACK = 1**， **ack = w + 1**, **seq = u + 1**
    - 在接收到确认报文之后，Server立即进入**CLOSED**状态
    - 而在发送完确认报文之后，Client进入**TIME-WAIT**状态。顾名思义，Client需要等待**2MSL**（最长报文寿命）的时间，再断开连接，进入**CLOSED**状态。

  - 为什么需要等待**2MSL**的时间？

    主要原因是为了保证Client最后发送的那个ACK报文能够到达Server。因为这个ACK报文可能丢失，由于**2MSL**是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。



















